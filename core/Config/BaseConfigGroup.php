<?php

declare(strict_types=1);

namespace Shimmie2;

abstract class BaseConfigGroup extends Enablable
{
    public ?string $title = null;
    public ?int $position = null;

    /**
     * Get all config fields from this config group.
     * Can be overridden by extensions who want to have dynamic config fields,
     * eg. Transcode having a map of <input mime type> -> <output mime type>
     * where valid inputs and outputs depend on what encoders are installed.
     *
     * @return array<string, ConfigMeta>
     */
    public function get_config_fields(): array
    {
        $fields = [];
        $refl_config = new \ReflectionClass($this);
        foreach ($refl_config->getConstants() as $const => $key) {
            $refl_const = $refl_config->getReflectionConstant($const);
            if (!$refl_const) {
                continue;
            }
            $attributes = $refl_const->getAttributes(ConfigMeta::class);
            if (count($attributes) == 0) {
                continue;
            }
            $meta = $attributes[0]->newInstance();
            $fields[$key] = $meta;
        }
        return $fields;
    }

    /**
     * Tweak the HTML generated by the config page, this allows extensions
     * to add extra bits before or after the form, or to totally ignore the
     * generated HTML and come up with their own renderer.
     */
    public function tweak_html(\MicroHTML\HTMLElement $html): \MicroHTML\HTMLElement
    {
        return $html;
    }

    /**
     * @return array<string, string>
     */
    public static function get_all_defaults(): array
    {
        return cache_get_or_set(
            get_called_class() . "_defaults_" . SysConfig::getVersion() . "_" . md5(Extension::get_enabled_extensions_as_string()),
            fn () => self::_get_all_defaults(),
            60
        );
    }

    /**
     * @return array<string, string>
     */
    public static function _get_all_defaults(): array
    {
        $defaults = [];
        foreach (self::get_subclasses() as $class) {
            $group = $class->newInstance();
            foreach ($class->getConstants() as $const => $value) {
                $refl_const = $class->getReflectionConstant($const);
                if (!$refl_const) {
                    continue;
                }
                $attributes = $refl_const->getAttributes(ConfigMeta::class);
                if (count($attributes) == 0) {
                    continue;
                }
                $meta = $attributes[0]->newInstance();
                if ($meta->default !== null) {
                    $defaults[$value] = match ($meta->type) {
                        ConfigType::BOOL => $meta->default ? "true" : "false",
                        ConfigType::INT => (string)($meta->default),
                        ConfigType::STRING => (string)($meta->default),
                        ConfigType::ARRAY => implode(",", $meta->default),
                    };
                }
            }
        }
        return $defaults;
    }
}
