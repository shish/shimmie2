<?php

declare(strict_types=1);

namespace Shimmie2;

abstract class BaseConfigGroup
{
    public const KEY = "";
    public ?string $title = null;
    public ?int $position = null;

    /**
     * Get all config fields from this config group.
     * Can be overridden by extensions who want to have dynamic config fields,
     * eg. Transcode having a map of <input mime type> -> <output mime type>
     * where valid inputs and outputs depend on what encoders are installed.
     *
     * @return array<string, ConfigMeta>
     */
    public function get_config_fields(): array
    {
        $fields = [];
        $refl_config = new \ReflectionClass($this);
        foreach ($refl_config->getConstants() as $const => $key) {
            $refl_const = $refl_config->getReflectionConstant($const);
            if (!$refl_const) {
                continue;
            }
            $attributes = $refl_const->getAttributes(ConfigMeta::class);
            if (count($attributes) == 0) {
                continue;
            }
            $meta = $attributes[0]->newInstance();
            $fields[$key] = $meta;
        }
        return $fields;
    }

    /**
     * Tweak the HTML generated by the config page, this allows extensions
     * to add extra bits before or after the form, or to totally ignore the
     * generated HTML and come up with their own renderer.
     */
    public function tweak_html(\MicroHTML\HTMLElement $html): \MicroHTML\HTMLElement
    {
        return $html;
    }

    /**
     * @return array<string, string>
     */
    public static function get_all_defaults(): array
    {
        return cache_get_or_set(
            get_called_class() . "_defaults_" . VERSION . "_" . md5(Extension::get_enabled_extensions_as_string()),
            fn () => self::_get_all_defaults(),
            60
        );
    }

    /**
     * @return array<string, string>
     */
    public static function _get_all_defaults(): array
    {
        $defaults = [];
        $base = get_called_class();
        foreach (get_subclasses_of($base) as $class) {
            $refl_group = new \ReflectionClass($class);
            $group = $refl_group->newInstance();
            assert(is_a($group, $base));
            if (!Extension::is_enabled($group::KEY)) {
                continue;
            }
            foreach ($refl_group->getConstants() as $const => $value) {
                $refl_const = $refl_group->getReflectionConstant($const);
                if (!$refl_const) {
                    continue;
                }
                $attributes = $refl_const->getAttributes(ConfigMeta::class);
                if (count($attributes) == 0) {
                    continue;
                }
                $meta = $attributes[0]->newInstance();
                if ($meta->default !== null) {
                    $defaults[$value] = match ($meta->type) {
                        ConfigType::BOOL => $meta->default ? "true" : "false",
                        ConfigType::INT => (string)($meta->default),
                        ConfigType::STRING => (string)($meta->default),
                        ConfigType::ARRAY => implode(",", $meta->default),
                    };
                }
            }
        }
        return $defaults;
    }
}

abstract class ConfigGroup extends BaseConfigGroup
{
}
abstract class UserConfigGroup extends BaseConfigGroup
{
}

enum ConfigType
{
    case BOOL;
    case INT;
    case STRING;
    case ARRAY;
}

#[\Attribute(\Attribute::TARGET_CLASS_CONSTANT)]
readonly class ConfigMeta
{
    /** @var "bool"|"int"|"shorthand_int"|"text"|"longtext"|"multichoice"|"color" */
    public string $input;

    /**
     * @param "shorthand_int"|"longtext"|"color" $input Override the default UI renderer
     * @param array<string, string>|callable-string|null $options A list of key-value pairs, or the name of a function to call to generate pairs
     */
    public function __construct(
        public string $label,
        public ConfigType $type,
        ?string $input = null,
        public mixed $default = null,
        public array|string|null $options = null,
        public ?string $permission = null,
        public ?string $help = null,
        public bool $advanced = false,
    ) {
        $this->input = $input ?? match($type) {
            ConfigType::BOOL => "bool",
            ConfigType::INT => "int",
            ConfigType::STRING => "text",
            ConfigType::ARRAY => "multichoice",
        };
    }
}
